#服务启动端口号
server:
  port: 8760
  tomcat:
    uri-encoding: UTF-8 #编码格式
    min-spare-threads: 100 #线程最小空闲线程数
    accept-count: 20000 #最大线程排队数 默认值为100
    max-threads: 1000 #最大同时处理的线程数 默认值为200
    max-connections: 20000 #最大连接数
    max-http-post-size: 0  #最大post数据的大小 0表示不限制
  connection-timeout: PT30S #修改请用 System.out.println(Duration.ofSeconds(30))  PT30S  PT1M

spring:
  application:
    name: zuul #当前项目的对外调用访问的名称
  cloud:
    loadbalancer:
      retry:
        enabled: true #该参数用来开启重试机制，它默认是关闭
  datasource:
    url: jdbc:mysql://192.168.1.172:3306/ehome_user?characterEncoding=utf8&useSSL=false
    username: root
    password: LiChengWang_20180531
    driver-class-name: com.mysql.jdbc.Driver
    platform: mysql
    # 使用druid数据源
    type: com.alibaba.druid.pool.DruidDataSource
    initialSize: 5 # 初始化大小
    minIdle: 3 # 最小空闲连接
    maxActive: 10 # 最大连接
#   maxWait: 60000 # 配置获取连接等待超时的时间
    timeBetweenEvictionRunsMillis: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
    # 配置一个连接在池中最小生存的时间，单位是毫秒
    minEvictableIdleTimeMillis: 30000
    validationQuery: select 'x'
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    # 打开PSCache，并且指定每个连接上PSCache的大小
    poolPreparedStatements: true
    maxPoolPreparedStatementPerConnectionSize: 20
    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
    filters: stat,wall,slf4j
    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
    # 合并多个DruidDataSource的监控数据
    #useGlobalDataSourceStat: true
  redis:
    database: 0  #数据库 默认0号库 0库用于存储用户相关信息
#    host: 192.168.1.163 #单机时需要指定
    password: LiChengWang_redis_20180604
#    port: 6379 #单机时需要指定
    timeout: PT10S # 连接超时时间（毫秒）默认是2000  改成10秒 修改请用 System.out.println(Duration.ofSeconds(10))
    jedis:
      pool:
        max-idle: 100 # 连接池中的最大空闲连接
        min-idle: 10 # 连接池中的最小空闲连接
        max-active: 1000 #连接池最大连接数
        max-wait: PT24H # 连接池最大阻塞等待时间 改成1天 修改请用 System.out.println(Duration.ofDays(1))
    sentinel: #哨兵配置
      master: mymaster #哨兵监听的Redis server的名称
      nodes: 192.168.1.160:26379 #哨兵多台时，分隔  如192.168.1.160:26379,192.168.1.163:26379

eureka:
  instance:
    hostname: localhost #主机名 目前只能写localhost 否则报错
    prefer-ip-address: true #显示IP
    instance-id: ${spring.application.name}:${spring.application.instance-id:${server.port}}
  client:
    serviceUrl:
      defaultZone: http://192.168.1.160:8761/eureka/

zuul:
  ribbonIsolationStrategy: THREAD #隔离模式
  host: #设置超时 三个时间最好保持一致
    socket-timeout-millis: 60000 #60秒
    connect-timeout-millis: 60000 #60秒
    maxTotalConnections: 100000 #总连接数
    maxPerRouteConnections: 10000 #单个路由的最大连接数
  semaphore:
    max-semaphores: 10000 #Zuul默认是使用信号量隔离，信号量默认大小是100 调高实现高并发
  retryable: true #开启重试机制
  routes:
    api-a:
      path: /demo-api/** #反向代理 对外访问路径 a、b、c、d、e、f、g、h、i、j、k、l、m、n、o、p、q、r、s、t、u、v、w、x、y、z
      service-id: demo #配置服务名称 实现负载均衡
    api-b:
      path: /login-api/** #登录注册和用户相关服务 反向代理 对外访问路径
      service-id: login #配置服务名称 实现负载均衡
    api-c:
          path: /ips-api/** #ips需求汇 反向代理 对外访问路径
          service-id: ips #配置服务名称 实现负载均衡
    api-d:
          path: /eblog-api/** #生活圈 反向代理 对外访问路径
          service-id: eblog #配置服务名称 实现负载均衡
    api-e:
          path: /activity-api/** #活动服务 反向代理 对外访问路径
          service-id: activity #配置服务名称 实现负载均衡
    api-f:
          path: /otherServer-api/** #其他服务 反向代理 对外访问路径
          service-id: otherServer #配置服务名称 实现负载均衡
    api-g:
          path: /paymentServer-api/** #支付服务 反向代理 对外访问路径
          service-id: paymentServer #配置服务名称 实现负载均衡
    api-h:
              path: /homeShop-shopCenter-api/** #家店店铺信息服务 反向代理 对外访问路径
              service-id: homeShop-shopCenter #配置服务名称 实现负载均衡
    api-i:
              path: /homeShop-goodsCenter-api/** #家店商品信息服务 反向代理 对外访问路径
              service-id: homeShop-goodsCenter #配置服务名称 实现负载均衡

hystrix: #设置超时 三个时间最好保持一致
  threadpool:
    default:
      coreSize: 100
      maximumSize: 10000 #最大线程数
      allowMaximumSizeToDivergeFromCoreSize: true #是否让maximumSize生效，false的话则只有coreSize会生效
      maxQueueSize: -1 #线程池的队列大小，-1代表使用SynchronousQueue队列
  command:
    default:
      execution:
        timeout:
          enabled: true #启用超时时间
        isolation:
          thread:
            timeoutInMilliseconds: 60000 #60秒

ribbon: #设置超时 三个时间最好保持一致
  ReadTimeout: 5000 #5秒
  ConnectTimeout: 5000 #5秒
  MaxAutoRetries: 1 # 同一实例最大重试次数，不包括首次调用
  MaxAutoRetriesNextServer: 1 # 重试其他实例的最大重试次数，不包括首次所选的server
  OkToRetryOnAllOperations: true #对所有请求操作都进行重试


